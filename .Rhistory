for (j in 1:m) {
for (i in 2:n) {
wealth[i,j] = (wealth[i-1,j] * ((1+path_equity[i,j])*glidepath_one[i,1] + (1+path_FI[i,j])*glidepath_one[i,2])) - withdraw[i,j]   #change glide path to 2
}
}
# calculate coverage ratio for every path
# if wealth at 30 year is still positive, coverage ratio > 1
cover = matrix(0, nrow = 1, ncol = m)
for (i in 1:m) {
if (wealth[nrow(wealth),i]<0) {
cover[i] = sum(wealth[,i]>0)/n
}
else {
cover[i] = (n+(wealth[nrow(wealth),i]/init))/n
}
}
#cover_ratio = mean(cover)
return(cover)
}
coverage_dist_to_utility_dist = function(coverage_ratio_dist, gamma, lambda,m) {
utility = matrix(0,nrow = 1, ncol = m)
for (i in 1:length(coverage_ratio)){
if (coverage_ratio[1,i] >= 1){
utility[1,i] = (coverage_ratio[1,i]^(1 - gamma) - 1) / (1 - gamma)
}
else{
utility[1,i] = ((1^(1 - gamma) - 1) / (1 - gamma)) - lambda*(1 - coverage_ratio[1,i])
}
}
return(utility)
}
coverage_to_utility = function(coverage_ratio, gamma, lambda) {
if (coverage_ratio >= 1){
utility = (coverage_ratio^(1 - gamma) - 1) / (1 - gamma)
}
else{
utility = ((1^(1 - gamma) - 1) / (1 - gamma)) - lambda*(1 - coverage_ratio)
}
return(utility)
}
num_path = 10000
SORR_risk = 0.2
initial_value_retirement = 100000
percent_year_withdrawal = 0.4
gamma_input = 0.9999
lambda_input = 10
portion_equity = 0.6
coverage_or_utility = 'coverage' # this should either equal to coverage or utility depending on what you would like to plot (will give you different graphs (everything will be automatic))
gene_path <- Simulated_Path_Given_SORR(SORR_risk,
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
results_hist = SORR_to_coverage_dist(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
e = initial_value_retirement,
x = percent_year_withdrawal,
n = 360,
m = num_path)
if (coverage_or_utility == 'coverage'){
median_hist = round(mean(results_hist),2)
sd_hist = round(sd(results_hist),2)
skew_hist = round(skewness(t(results_hist)),2)
kurtosis_hist = round(kurtosis(t(results_hist)),2)
hist(results_hist,
breaks = 50,
xlab = 'Coverage Ratio',
main = paste(c('Mean = ', median_hist,
' / SD = ', sd_hist,
' / Skew = ', skew_hist,
' / Kurtosis = ', kurtosis_hist),
collapse = ''))
} else{
median_utility = round(mean(results_utility),2)
sd_utility = round(sd(results_utility),2)
skew_utility = round(skewness(t(results_utility)),2)
kurtosis_utility = round(kurtosis(t(results_utility)),2)
hist(results_utility,
breaks = 50,
xlab = 'Utility Coverage Ratio',
main = paste(c('Mean = ', median_utility,
' / SD = ', sd_utility,
' / Skew = ', skew_utility,
' / Kurtosis = ', kurtosis_utility),
collapse = ''))
}
num_path = 10000
SORR_risk = 0.2
initial_value_retirement = 200000
percent_year_withdrawal = 0.2
gamma_input = 0.9999
lambda_input = 10
portion_equity = 0.6
coverage_or_utility = 'coverage' # this should either equal to coverage or utility depending on what you would like to plot (will give you different graphs (everything will be automatic))
gene_path <- Simulated_Path_Given_SORR(SORR_risk,
num_path)
gene_path <- Simulated_Path_Given_SORR(SORR_risk,
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
results_hist = SORR_to_coverage_dist(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
e = initial_value_retirement,
x = percent_year_withdrawal,
n = 360,
m = num_path)
results_hist = SORR_to_coverage_dist(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
e = initial_value_retirement,
x = percent_year_withdrawal,
n = 360,
m = num_path)
if (coverage_or_utility == 'coverage'){
median_hist = round(mean(results_hist),2)
sd_hist = round(sd(results_hist),2)
skew_hist = round(skewness(t(results_hist)),2)
kurtosis_hist = round(kurtosis(t(results_hist)),2)
hist(results_hist,
breaks = 50,
xlab = 'Coverage Ratio',
main = paste(c('Mean = ', median_hist,
' / SD = ', sd_hist,
' / Skew = ', skew_hist,
' / Kurtosis = ', kurtosis_hist),
collapse = ''))
} else{
median_utility = round(mean(results_utility),2)
sd_utility = round(sd(results_utility),2)
skew_utility = round(skewness(t(results_utility)),2)
kurtosis_utility = round(kurtosis(t(results_utility)),2)
hist(results_utility,
breaks = 50,
xlab = 'Utility Coverage Ratio',
main = paste(c('Mean = ', median_utility,
' / SD = ', sd_utility,
' / Skew = ', skew_utility,
' / Kurtosis = ', kurtosis_utility),
collapse = ''))
}
num_path = 10000
SORR_risk = 0.2
initial_value_retirement = 300000
percent_year_withdrawal = 0.13
gamma_input = 0.9999
lambda_input = 10
portion_equity = 0.6
coverage_or_utility = 'coverage' # this should either equal to coverage or utility depending on what you would like to plot (will give you different graphs (everything will be automatic))
gene_path <- Simulated_Path_Given_SORR(SORR_risk,
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
results_hist = SORR_to_coverage_dist(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
e = initial_value_retirement,
x = percent_year_withdrawal,
n = 360,
m = num_path)
if (coverage_or_utility == 'coverage'){
median_hist = round(mean(results_hist),2)
sd_hist = round(sd(results_hist),2)
skew_hist = round(skewness(t(results_hist)),2)
kurtosis_hist = round(kurtosis(t(results_hist)),2)
hist(results_hist,
breaks = 50,
xlab = 'Coverage Ratio',
main = paste(c('Mean = ', median_hist,
' / SD = ', sd_hist,
' / Skew = ', skew_hist,
' / Kurtosis = ', kurtosis_hist),
collapse = ''))
} else{
median_utility = round(mean(results_utility),2)
sd_utility = round(sd(results_utility),2)
skew_utility = round(skewness(t(results_utility)),2)
kurtosis_utility = round(kurtosis(t(results_utility)),2)
hist(results_utility,
breaks = 50,
xlab = 'Utility Coverage Ratio',
main = paste(c('Mean = ', median_utility,
' / SD = ', sd_utility,
' / Skew = ', skew_utility,
' / Kurtosis = ', kurtosis_utility),
collapse = ''))
}
SORR_measure = seq(0.1, 1, by=0.1)
print(SORR_measure)
class(SORR_measure)
SORR_measure[1]
SORR_measure[3]
SORR_to_coverage_fix = function(path_equity,path_FI,path_Inflation,a,start_point=0,end_point=0,e,n,m) {
withdraw = matrix(0,nrow = n, ncol = m)
#first glidepath, constant
glidepath_one = matrix(0,nrow = n, ncol = 2)
glidepath_one[,1] = a
glidepath_one[,2] = 1-a
#second glidepath
glidepath_two = matrix(0,nrow = n, ncol = 2)
rate = (end_point - start_point)/n  #changing rate
glidepath_two[,1] = seq(from = start_point, to = end_point-rate, by = rate)
glidepath_two[,2] = 1-glidepath_two[,1]
init = 40000
withdraw[1,] = init
for (i in 2:nrow(dt)) {
for (j in 1:ncol(path_Inflation)) {
withdraw[i,j] = withdraw[i-1,j] * (1+path_Inflation[i,j])
}
}
wealth = matrix(0,nrow = n, ncol = m)
wealth[1,] = e
#calculate wealth position at specific time point after withdraw
for (j in 1:m) {
for (i in 2:n) {
wealth[i,j] = (wealth[i-1,j] * ((1+path_equity[i,j])*glidepath_one[i,1] + (1+path_FI[i,j])*glidepath_one[i,2])) - withdraw[i,j]   #change glide path to 2
}
}
# calculate coverage ratio for every path
# if wealth at 30 year is still positive, coverage ratio > 1
cover = matrix(0, nrow = 1, ncol = m)
for (i in 1:m) {
if (wealth[nrow(wealth),i]<0) {
cover[i] = sum(wealth[,i]>0)/n
}
else {
cover[i] = (n+(wealth[nrow(wealth),i]/init))/n
}
}
cover_ratio = mean(cover)
return(cover_ratio)
}
output_num = matrix(0,nrow = 10, ncol = 90)
for (i in 1:10){
for (j in 10:100){
output_num[i,j] = SORR_to_coverage(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 10000,
n = 360,
m = num_path)
}
}
for (i in 1:10){
for (j in 10:100){
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 10000,
n = 360,
m = num_path)
}
}
output_num = matrix(0,nrow = 10, ncol = 90)
for (i in 1:10){
for (j in 1:10){
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
}
SORR_to_coverage_fix = function(path_equity,path_FI,path_Inflation,a,start_point=0,end_point=0,e,n,m) {
withdraw = matrix(0,nrow = n, ncol = m)
#first glidepath, constant
glidepath_one = matrix(0,nrow = n, ncol = 2)
glidepath_one[,1] = a
glidepath_one[,2] = 1-a
#second glidepath
glidepath_two = matrix(0,nrow = n, ncol = 2)
rate = (end_point - start_point)/n  #changing rate
glidepath_two[,1] = seq(from = start_point, to = end_point-rate, by = rate)
glidepath_two[,2] = 1-glidepath_two[,1]
init = (40000 / 12)
withdraw[1,] = init
for (i in 2:nrow(dt)) {
for (j in 1:ncol(path_Inflation)) {
withdraw[i,j] = withdraw[i-1,j] * (1+path_Inflation[i,j])
}
}
wealth = matrix(0,nrow = n, ncol = m)
wealth[1,] = e
#calculate wealth position at specific time point after withdraw
for (j in 1:m) {
for (i in 2:n) {
wealth[i,j] = (wealth[i-1,j] * ((1+path_equity[i,j])*glidepath_one[i,1] + (1+path_FI[i,j])*glidepath_one[i,2])) - withdraw[i,j]   #change glide path to 2
}
}
# calculate coverage ratio for every path
# if wealth at 30 year is still positive, coverage ratio > 1
cover = matrix(0, nrow = 1, ncol = m)
for (i in 1:m) {
if (wealth[nrow(wealth),i]<0) {
cover[i] = sum(wealth[,i]>0)/n
}
else {
cover[i] = (n+(wealth[nrow(wealth),i]/init))/n
}
}
cover_ratio = mean(cover)
return(cover_ratio)
}
output_num = matrix(0,nrow = 10, ncol = 90)
for (i in 1:10){
for (j in 1:10){
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
}
output_num = matrix(0,nrow = 10, ncol = 90)
for (i in 1:10){
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
for (j in 1:10){
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
}
print(output_num)
SORR_to_coverage_fix = function(path_equity,path_FI,path_Inflation,a,start_point=0,end_point=0,e,n,m) {
withdraw = matrix(0,nrow = n, ncol = m)
#first glidepath, constant
glidepath_one = matrix(0,nrow = n, ncol = 2)
glidepath_one[,1] = a
glidepath_one[,2] = 1-a
#second glidepath
glidepath_two = matrix(0,nrow = n, ncol = 2)
rate = (end_point - start_point)/n  #changing rate
glidepath_two[,1] = seq(from = start_point, to = end_point-rate, by = rate)
glidepath_two[,2] = 1-glidepath_two[,1]
init = (40000 / 12)
withdraw[1,] = init
for (i in 2:nrow(dt)) {
for (j in 1:ncol(path_Inflation)) {
withdraw[i,j] = withdraw[i-1,j] * (1+path_Inflation[i,j])
}
}
wealth = matrix(0,nrow = n, ncol = m)
wealth[1,] = e
#calculate wealth position at specific time point after withdraw
for (j in 1:m) {
for (i in 2:n) {
wealth[i,j] = (wealth[i-1,j] * ((1+path_equity[i,j])*glidepath_one[i,1] + (1+path_FI[i,j])*glidepath_one[i,2])) - withdraw[i,j]   #change glide path to 2
}
}
# calculate coverage ratio for every path
# if wealth at 30 year is still positive, coverage ratio > 1
cover = matrix(0, nrow = 1, ncol = m)
for (i in 1:m) {
if (wealth[nrow(wealth),i]<0) {
cover[i] = sum(wealth[,i]>0)/n
}
else {
cover[i] = (n+(wealth[nrow(wealth),i]/init))/n
}
}
cover_ratio = mean(cover)
return(cover_ratio)
}
output_num = matrix(0,nrow = 10, ncol = 10)
for (i in 1:10){
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
for (j in 1:10){
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
return(output_num)
}
print(output_num)
output_num = matrix(0,nrow = 10, ncol = 10)
for (i in 1:10){{
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
for (j in 1:10){
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
}
return(output_num)
}
print(output_num)
output_num = matrix(0,nrow = 10, ncol = 10)
for (i in 1:10){
# generate the paths
gene_path <- Simulated_Path_Given_SORR((i / 10),
num_path)
path_equity <- gene_path[[1]]
path_FI <- gene_path[[2]]
path_Inflation <- gene_path[[3]]
for (j in 1:10){
# generate the number
output_num[i,j] = SORR_to_coverage_fix(path_equity = path_equity,
path_FI = path_FI,
path_Inflation = path_Inflation,
a = portion_equity,
start_point=0,
end_point=0,
e = j * 100000,
n = 360,
m = num_path)
}
}
print(output_num)
library(ggplot2)
plot(output_num[1,])
fig = plot(output_num[1,])
plot(output_num[2,])
plot(output_num[1,])
plot(output_num[2,])
plot(output_num[1,],type='l')
?matplot
install.packages('matplot')
#plot(output_num[1,],type='l')
matplot(output_num, type = c("b"),pch=1,col = 1:4)
#plot(output_num[1,],type='l')
matlines(output_num, type = c("b"),pch=1,col = 1:4)
#plot(output_num[1,],type='l')
matplot(t(output_num), type = c("b"),pch=1,col = 1:10)
matplot(t(output_num), type = c("b"),pch=1,col = 1:10, xlab = 'Income (in $100k)', ylab = 'Coverage Ratio')
matplot(t(output_num),
type = c("b"),
pch=1,
col = 1:10,
xlab = 'Income (in $100k)',
ylab = 'Coverage Ratio',
main = 'With Annual Withdrawal of 40,000 p.a.')
matplot(t(output_num),
type = c("b"),
pch=1,
col = 1:10,
xlab = 'Income (in $100k)',
ylab = 'Coverage Ratio',
main = 'With Annual Withdrawal of $40,000 p.a.')
?matplot
